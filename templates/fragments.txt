{% macro uart_define() %}
// UART defines
// By default the stdout UART is `uart0`, so we will use the second one
#define UART_ID uart1
#define BAUD_RATE 9600
// Use pins 4 and 5 for UART1
// Pins can be changed, see the GPIO function select table in the datasheet for information on GPIO assignments
#define UART_TX_PIN 4
#define UART_RX_PIN 5 
{% endmacro %}

{% macro uart_initialiser() %}
// Set up our UART
uart_init(UART_ID, BAUD_RATE);
// Set the TX and RX pins by using the function select on the GPIO
// Set datasheet for more information on function select
gpio_set_function(UART_TX_PIN, GPIO_FUNC_UART);
gpio_set_function(UART_RX_PIN, GPIO_FUNC_UART);
{% endmacro %}

{% macro spi_define() %}
// SPI Defines
// We are going to use SPI 0, and allocate it to the following GPIO pins,
// Pins can be changed, see the GPIO function select table in the datasheet for information on GPIO assignments,
#define SPI_PORT spi0
#define PIN_MISO 16
#define PIN_CS   17
#define PIN_SCK  18
#define PIN_MOSI 19 
{% endmacro %}

{% macro spi_initialiser() %}
// SPI initialisation. This example will use SPI at 1MHz.
spi_init(SPI_PORT, 1000*1000);
gpio_set_function(PIN_MISO, GPIO_FUNC_SPI);
gpio_set_function(PIN_CS,   GPIO_FUNC_SIO);
gpio_set_function(PIN_SCK,  GPIO_FUNC_SPI);
gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI); 
// Chip select is active-low, so we'll initialise it to a driven-high state
gpio_set_dir(PIN_CS, GPIO_OUT);
gpio_put(PIN_CS, 1);
{% endmacro %}

{% macro i2c_define() %}
// I2C defines
// This example will use I2C0 on GPIO8 (SDA) and GPIO9 (SCL) running at 400KHz.
// Pins can be changed, see the GPIO function select table in the datasheet for information on GPIO assignments
#define I2C_PORT i2c0
#define I2C_SDA 8
#define I2C_SCL 9
{% endmacro %}

{% macro i2c_initialiser() %}
// I2C Initialisation. Using it at 400Khz.
i2c_init(I2C_PORT, 400*1000);
gpio_set_function(I2C_SDA, GPIO_FUNC_I2C);
gpio_set_function(I2C_SCL, GPIO_FUNC_I2C);
gpio_pull_up(I2C_SDA);
gpio_pull_up(I2C_SCL);
{% endmacro %}

{% macro gpio_define() %}
// GPIO defines
// Example uses GPIO 2
#define GPIO 2
{% endmacro %}

{% macro gpio_initialiser() %}
// GPIO initialisation.
// We will make this GPIO an input, and pull it up by default
gpio_init(GPIO);
gpio_set_dir(GPIO, GPIO_IN);
gpio_pull_up(GPIO);
{% endmacro %}

{% macro interp_define() %}{% endmacro %}

{% macro interp_initialiser() %}
// Interpolator example code
interp_config cfg = interp_default_config();
// Now use the various interpolator library functions for your use case
// e.g. interp_config_clamp(&cfg, true);
//      interp_config_shift(&cfg, 2);
// Then set the config 
interp_set_config(interp0, 0, &cfg);
{% endmacro %}

{% macro timer_define() %}
int64_t alarm_callback(alarm_id_t id, void *user_data) {
    // Put your timeout handler code in here
    return 0;
}
{% endmacro %}

{% macro timer_initialiser() %}
// Timer example code - This example fires off the callback after 2000ms
add_alarm_in_ms(2000, alarm_callback, NULL, false);
{% endmacro %}

{% macro watchdog_define() %}
{% endmacro %}

{% macro watchdog_initialiser() %}
// Watchdog example code
if (watchdog_caused_reboot()) {
    // Whatever action you may take if a watchdog caused a reboot
}
// Enable the watchdog, requiring the watchdog to be updated every 100ms or the chip will reboot
// second arg is pause on debug which means the watchdog will pause when stepping through code
watchdog_enable(100, 1);
// You need to call this function at least more often than the 100ms in the enable call to prevent a reboot
watchdog_update();
{% endmacro %}

{% macro div_define() %}
{% endmacro %}

{% macro div_initialiser() %}
// Example of using the HW divider. The pico_divider library provides a more user friendly set of APIs 
// over the divider (and support for 64 bit divides), and of course by default regular C language integer
// divisions are redirected thru that library, meaning you can just use C level `/` and `%` operators and
// gain the benefits of the fast hardware divider.
int32_t dividend = 123456;
int32_t divisor = -321;
// This is the recommended signed fast divider for general use.
divmod_result_t result = hw_divider_divmod_s32(dividend, divisor);
printf(\%d/%d = %d remainder %d\\n\, dividend, divisor, to_quotient_s32(result), to_remainder_s32(result));
// This is the recommended unsigned fast divider for general use.
int32_t udividend = 123456;
int32_t udivisor = 321;
divmod_result_t uresult = hw_divider_divmod_u32(udividend, udivisor);
printf(\%d/%d = %d remainder %d\\n\, udividend, udivisor, to_quotient_u32(uresult), to_remainder_u32(uresult));
{% endmacro %}

{% macro dma_define() %}{% endmacro %}

{% macro dma_initialiser() %}{% endmacro %}

{% macro pio_define() %}{% endmacro %}

{% macro pio_initialiser() %}{% endmacro %}

{% macro clocks_define() %}{% endmacro %}

{% macro clocks_initialiser() %}{% endmacro %}
